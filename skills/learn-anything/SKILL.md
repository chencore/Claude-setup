---
name: learn-anything
description: 元学习技能，通过识别关键的 20% 材料、构建专家词汇表和创建基于研究的学习路线图来高效掌握任何主题。当用户说"学习 [主题]"，"帮助我学习 [主题]"，"我想学习 [主题]"或询问理解新主题的指导时自动触发。支持全面计划、交互式指导或简约的及时交付
---

# Learn Anything

使用元学习原则将"我想学习 X"转化为可执行的学习路线图：识别关键的 20%，构建专家词汇表，逻辑排序（先为什么后如何），优先考虑当前最佳实践。

## 何时使用

当用户：
- 说"学习 [主题]"或"帮助我学习 [主题]"
- 问"我如何开始 [主题]？"
- 请求掌握新事物的结构化方法

不要在以下情况使用：
- 用户拥有内容并想要行动计划（使用 ship-learn-next）
- 请求实施帮助，而不是学习

## 核心原则

1. **帕累托重点**：识别提供 80% 实际价值的 20% 材料
2. **逻辑排序**：基础在细节前，为什么在如何前
3. **词汇优先**：构建专家词汇表以获得更好的理解和提示
4. **实用偏向**：优化适用知识而不是全面覆盖

## 状态管理 - 全局 ~/.learn 目录

所有学习工件都全局保存在 `~/.learn/[topic-slug]/`：

```
~/.learn/
├── react/
│   ├── plan.md              # 学习计划（所有模式）
│   ├── progress.json        # 状态跟踪（交互/简约）
│   ├── vocabulary.md        # 依赖排序的词汇
│   ├── notes.md            # 用户的学习笔记（可选）
│   └── apps/               # 交互式应用提示（交互/简约）
│       ├── components.md
│       ├── hooks.md
│       └── state-management.md
├── rust/
│   ├── plan.md
│   ├── progress.json
│   ├── vocabulary.md
│   └── apps/
│       └── ownership.md
```

**好处**：学习状态跨所有项目持续存在。可以从任何目录继续学习。

**设置**：如果不存在，首次使用时创建 `~/.learn/` 目录。使用主题 slug（小写，连字符）作为子目录名。

## 三种输出模式

**模式选择**：在研究前询问偏好（影响材料结构）。如果不清楚，默认为全面。

### 全面计划（默认）
- **交付**：保存包含详细的 20% 入门包和完整路线图的完整 `plan.md`
- **状态**：不需要进度跟踪
- **最适合**：想要完整图片 upfront 的自导向学习者
- **工件**：只有 `~/.learn/[topic]/plan.md`

### 交互式指南
- **交付**：一次呈现一个概念，在进展前验证理解
- **状态**：在 `progress.json` 中跟踪进度，随着用户完成概念更新
- **最适合**：想要问责和验证的学习者
- **工件**：`plan.md` + `progress.json` + `vocabulary.md`
- **灵活性**：允许回滚，概念重新排序，旅程中添加概念

### 简约及时
- **交付**：只有下一个资源和关键术语
- **状态**：在 `progress.json` 中跟踪进度，用户返回时获取下一步
- **最适合**：避免分析瘫痪的行动导向学习者
- **工件**：简约的 `plan.md` + `progress.json` + `vocabulary.md`
- **灵活性**：允许回滚，概念重新排序，旅程中添加概念

## 恢复现有学习

开始新的学习计划前，检查 `~/.learn/[topic-slug]/` 是否存在：

**如果存在**：
1. 读取 `progress.json` 检查模式和当前状态
2. 问："我找到了 [主题] 的现有学习计划。您想要：A) 从离开的地方继续，B) 重新开始，C) 审查您的进度？"

**如果继续**：
- 从 progress.json 加载当前概念
- 基于模式（交互/简约）呈现下一步或提醒他们计划
- 呈现新材料时引用已经学习的内容

**如果重新开始**：
- 将旧目录归档到 `~/.learn/[topic]-archive-[timestamp]/`
- 继续新的学习计划

**如果审查进度**：
- 显示完成的概念、当前概念、已学习的词汇
- 允许修改："想要回到任何概念吗？添加新概念？继续向前？"

## 工作流程

### 步骤 1：理解意图

从用户请求中提取主题，然后问 2-3 个问题以了解上下文：

**专注于意图和应用：**
- "什么驱使您学习 [主题]？"（工作项目 / 职业转变 / 构建特定东西 / 纯粹好奇心）
- "您将在哪里应用这些知识？"（特定项目 / 通用技能 / 专业要求 / 个人探索）
- "您对 [主题] 或相关领域目前的经验是什么？"（完全初学者 / 一些接触 / 熟悉相邻主题）

使用 AskUserQuestion 与对话式选择题。保持简短 - 收集足够信息以定制计划。

### 步骤 2：智能研究

基于主题成熟度和生态系统进行自适应网络搜索：

**搜索策略（按主题调整）：**

对于已建立的技术/领域：
- "[topic] 官方文档"
- "[topic] reddit"（查找社区讨论，实际从业者意见）
- "[topic] 学习路径"或"[topic] 路线图"
- "入门 [topic]"（初学者资源）
- "[topic] vs [替代]"（了解定位和用例）

对于新兴/小众主题：
- "[topic] github"（查找项目、示例、实际使用）
- "[topic] 教程"
- "[topic] 是什么"（了解当前状态）
- "[topic] 用例"（实际应用）

对于学术/理论主题：
- "[topic] 课程"
- "[topic] 教材推荐"
- "[topic] 解释"（可访问的介绍）

**研究目标：**
1. 当前状态和最近发展（什么现代 vs 过时）
2. 最高影响资源（官方文档，受尊重的课程， definitive 指南）
3. 专家词汇（术语，行话，缩写）
4. 学习依赖（先决条件，逻辑排序）
5. 常见陷阱和令人困惑的概念

**资源质量信号：**
- 官方/维护的文档
- 社区共识（upvotes，推荐）
- 最近发布（与当前实践的相关性）
- 初学者友好 vs 高级（匹配用户级别）
- 免费和可访问

运行 4-6 次搜索，根据发现的内容调整。不要盲目遵循模板。

### 步骤 3：识别关键 20%

分析研究以提取提供最大基础的 3-7 个核心主题。

**选择标准：**
- 解锁对其他概念的理解
- 在实践中经常使用
- 基础 vs 好知道
- 当前的最佳实践（跳过过时的/弃用的）

对于每个核心主题：
- 为什么重要（概念基础）
- 1-2 个最高影响资源
- 5-10 个关键词汇术语
- 时间估计
- 获得的具体能力

**示例（React）：**
- 20%：组件、JSX、Props/State、Hooks、事件处理
- 不是 20%：类组件（过时），高级模式，SSR（稍后），测试（稍后）

### 步骤 4：构建完整路线图

将剩余主题排序为基础 → 中级 → 高级。

对于 20% 之外的每个主题：
- 简短描述
- 为什么重要
- 一个最高影响资源
- 标记可选 vs 必需

保持精益。这是地图，不是详细说明。

### 步骤 5：编译词汇表

构建**基于依赖的词汇序列** - 按概念依赖而不是任意层级排序术语。

**排序原则**：在学习依赖它们的术语之前先学习基础术语。

示例（React）：
1. **组件**（基础 - 需要一切）
2. **JSX**（语法 - 需要编写组件）
3. **Props**（组件输入 - 构建在组件理解上）
4. **State**（组件数据 - 与 props 平行）
5. **Hook**（用于状态/效果的函数 - 构建在状态概念上）
6. **useState**（特定 hook - 构建在 hook 概念上）
7. **useEffect**（特定 hook - 构建在 hook + 组件生命周期上）

**覆盖**：识别覆盖 20% 材料的 10-30 个术语。如果依赖需要更多术语，包含它们。总是从第一原理开始。

**每个术语的格式**：
```
**术语**：定义（1 句）+ 为什么重要/何时使用
依赖：[如果需要，先知道的术语]
```

**对于交互/简约模式**：将词汇预排序以匹配概念顺序。当每个概念介绍时，仅呈现其术语和依赖（构建在已学习的术语上）。

**对于全面模式**：在 plan.md 中呈现完整的排序词汇列表。

**保存到**：`~/.learn/[topic]/vocabulary.md` 并带依赖指示器。

### 步骤 6：生成交互式应用提示（当有益时）

对于交互和简约模式，为显著增强学习的概念生成创意应用提示。

**何时生成应用提示：**
- 视觉/空间概念（UI 组件、布局、动画、数据结构）
- 算法概念（排序、搜索、递归、状态机）
- 交互模式（事件处理、状态管理、用户流程）
- 从可视化中受益的抽象概念（闭包、异步、内存管理）
- **跳过**：纯理论，历史背景，简单定义，工具安装

**应用设计原则：**

生成最大化通过交互学习的完全自定义应用想法。考虑：

1. **主动学习**：用户操作、构建或实验（不仅仅是阅读/观看）
2. **即时反馈**：视觉/交互响应显示概念的实际作用
3. **渐进复杂性**：从简单开始，允许探索边缘情况
4. **概念隔离**：专注于一个核心概念，避免被相关主题压垮
5. **游戏化发现**：使其有趣 - 游戏、挑战、创意工具超过枯燥的练习

**创意应用类型**（示例，不是模板）：
- **构建器**："构建你自己的 X" - 从组件构建概念
- **模拟器**：显示概念行为的交互模拟
- **可视化器**：实时动画或可视化抽象概念
- **沙盒**：具有即时视觉反馈的实验沙盒
- **游戏**：游戏化学习（例如，"更快地排序数组"，"捕获错误"）
- **探索器**：用户探索概念空间的交互式文档
- **挑战**：需要应用概念的谜题/问题解决

**提示生成过程**：

对于每个需要应用的概念：

1. **识别核心学习目标**：使用此应用后用户应该从 visceral 上理解什么？
2. **设计交互**：用户将如何交互？他们将构建/操作/探索什么？
3. **确定要求**：需要图像生成吗？需要 LLM 进行动态内容吗？都不需要？
4. **编写简洁提示**（50-150 字）：
   - 应用名称和核心想法
   - 用户做什么（交互模型）
   - 他们通过交互学到什么
   - 技术要求："要求：图像生成"或"要求：LLM 用于动态示例"或"仅静态交互 UI"

**提示格式：**

```markdown
### 交互式学习应用：[概念名称]

**应用想法**：[创意名称 - 2-4 个词]

[应用和用户做什么的 2-3 句描述]

**学习目标**：[通过交互变得清晰的概念]

**要求**：[图像生成 / LLM / 都不 - 仅交互式 UI]

**Google AI Studio 提示**：
---
[描述要构建的应用的简洁 50-150 字提示]---
```

**示例：**

对于"React 组件"：
```
**应用想法**：组件构建器

通过拖放视觉元素并实时查看 JSX 代码生成来构建 React 组件。点击组件查看 props，修改值以重新渲染。有意破坏事物以理解组件边界。

**学习目标**：通过视觉操作理解组件组成、props 流和重新渲染。

**要求**：仅静态交互式 UI

**Google AI Studio 提示**：
---
创建一个交互式网络应用，用户在其中可视化构建 React 组件。左侧：拖放元素（按钮、输入、div、文本）。右侧：实时 JSX 代码生成。用户可以点击任何组件编辑 props，查看更改如何传播。包含一个"破坏它"按钮，引入常见错误（缺少键，错误的 prop 类型）以学习调试。实时视觉更新。使其有趣和多彩。
---
```

对于"排序算法"：
```
**应用想法**：排序竞赛可视化器

观看不同排序算法在彩色条表示的数组上实时竞争。调整速度、数组大小和初始顺序。查看比较和交换。预测哪种算法在不同数据模式中获胜。

**学习目标**：通过视觉竞赛直观理解算法性能。

**要求**：仅静态交互式 UI

**Google AI Studio 提示**：
---
构建排序算法竞赛可视化器。显示 3-4 个算法（气泡、快速、归并、插入）同时运行在相同的数组上，表示为彩色条。动画每个比较和交换，具有平滑过渡。控件：速度滑块，数组大小，初始顺序（随机，排序，反转）。显示实时统计：比较，交换，时间。添加"竞赛模式"让算法竞争。使其感觉像具有兴奋动画和声音效果（可选）的游戏。用户通过发现模式来学习。
---
```

对于"JavaScript 闭包"：
```
**应用想法**：闭包工厂探索器

创建"记住"值的函数。通过锁定变量构建闭包，然后用不同输入调用它们以查看哪些数据持续 vs 更改。视觉内存框显示捕获的作用域。

**学习目标**：通过交互式函数构建理解词法作用域和变量捕获。

**要求**：LLM 用于动态代码生成和解释

**Google AI Studio 提示**：
---
创建一个交互式闭包探索器。用户编写从外部作用域捕获变量的简单函数。应用显示表示作用域的视觉"内存框" - 外部和内部。当函数被调用时，突出显示来自何处哪些变量。使用 LLM（简单的计数器、事件处理程序、私有数据模式）生成多样示例。让用户修改代码并看到作用域可视化更新。用普通语言解释闭包行为。使不可见的东西可见。
---
```

**存储和交付：**

1. 将应用提示保存到 `~/.learn/[topic]/apps/[concept-slug].md`
2. 在对话中呈现概念时显示内联
3. 将其视为可选补充材料（不要阻止进度）

**在交互模式中**：在呈现资源后，理解检查前显示应用提示
**在简约模式中**：与资源链接和词汇一起显示应用提示

### 步骤 7：生成输出

#### 模式 1：全面计划

保存到 `~/.learn/[topic]/plan.md` 与结构：

```markdown
# 学习计划：[主题]

**上下文**：[当前级别] | [目标/应用] | 生成：[日期]

## 前 20% - 入门包

### 1. [核心主题]
**为什么**：[概念解释]
**词汇**：[带依赖的术语]
**资源**：[URL] - [为什么有价值] - 时间：[估计]
**之后**：[获得的能力]

[对 3-7 个核心主题重复]

## 完整路线图
### 中级：[主题带简短描述 + 资源]
### 高级：[主题带简短描述 + 资源]
### 可选：[需要时]

## 词汇参考
[依赖排序的术语与定义 - 来自 vocabulary.md]

## 学习提示
[3-5 个提示：陷阱，最佳实践，社区]

## 下一步
从主题 1 开始，学习词汇，完成资源，评估下一步。
```

保存后：确认位置，总结 20%，鼓励行动。

#### 模式 2：交互式指南

**初始设置**：
1. 创建 `~/.learn/[topic]/` 目录
2. 保存具有完整学习计划的 `plan.md`（供参考）
3. 保存依赖排序术语的 `vocabulary.md`
4. 初始化 `progress.json`：

```json
{
  "mode": "interactive",
  "topic": "React",
  "current_concept": 1,
  "concepts": [
    {"id": 1, "name": "Components", "status": "in_progress", "started_at": "2025-01-15"},
    {"id": 2, "name": "JSX", "status": "pending"},
    {"id": 3, "name": "Props & State", "status": "pending"}
  ],
  "vocabulary_progress": {
    "learned": [],
    "current": ["component", "render"],
    "upcoming": ["jsx", "props", "state"]
  },
  "history": []
}
```

**交付流程**：

**首次交互** - 呈现当前概念：
```
📚 学习 React - 概念 1/5：组件

**为什么这很重要**：[概念解释]

**此概念的词汇**：
- **组件**：[定义 + 用法]
  依赖：无（基础）
- **渲染**：[定义 + 用法]
  依赖：组件

**资源**：[名称 + URL]
为什么这个资源有价值：[什么使其有价值]
时间：[估计]

[如果概念从交互应用中受益，在此处显示应用提示：]

**🎮 交互式学习应用**：[应用名称]
[描述和学习目标]
[Google AI Studio 提示在代码块中]
保存到： ~/.learn/react/apps/components.md

**完成后**：返回后我会在移到 JSX 前检查您的理解。

进度已保存到： ~/.learn/react/progress.json
```

**当用户返回时** - 检查理解：
```
欢迎回来！让我们验证您对组件的理解。

快速检查：
- 用您自己的话，什么是组件？
- 渲染如何工作？

[基于响应：]
✓ 理解很好 → 更新 progress.json，移动到概念 2
⚠ 一些差距 → 澄清误解，提供补充资源
✗ 在挣扎 → 建议重做资源或不同方法，保持在概念 1
```

**状态更新**：
- 将概念标记为已完成，更新 `vocabulary_progress.learned`
- 将下一个概念设置为 "in_progress"
- 添加到 `history` 数组
- 保存 progress.json

**灵活性命令**（用户随时可以说这些）：
- "回到 [概念]" → 回滚，将该概念设置为 "in_progress"，添加到历史
- "我想复习 [概念]" → 允许重新学习，构建在之前教授的内容上
- "添加关于 [主题] 的概念" → 插入到 concepts 数组，更新序列
- "跳到 [概念]" → 将当前标记为已完成，跳 ahead（允许但不鼓励）
- "显示我的进度" → 从 progress.json 显示当前状态

**对话风格**：一次一个概念，验证前验证，自适应节奏，鼓励的语气。引入新术语时构建在已学习的词汇上。

#### 模式 3：简约及时

**初始设置**：
1. 创建 `~/.learn/[topic]/` 目录
2. 保存简约 `plan.md`（仅概念列表 + 简短描述）
3. 保存依赖排序术语的 `vocabulary.md`
4. 初始化 `progress.json`（与交互模式相同结构）

**交付流程**：

**首次交互** - 简约，可操作：
```
🎯 学习 React - 步骤 1/5：组件

从这里开始：[资源名称 + URL]
时间：约 2 小时

要理解的关键术语：
- **组件**：[定义]
  依赖：无
- **渲染**：[定义]
  依赖：组件

[如果概念受益于交互应用：]

🎮 可选交互应用：[应用名称]
[Google AI Studio 提示 - 简洁版本]
完整提示保存： ~/.learn/react/apps/components.md

完成后返回。

进度： ~/.learn/react/progress.json
```

**当用户返回时** - 简短检查 + 下一步：
```
欢迎回来！

快速：您关于组件学到了什么关键事情？

[基于响应 - 简要承认]

下一步：JSX（步骤 2/5）
资源：[URL]
时间：约 1 小时

新词汇（构建在您知道的内容上）：
- **JSX**：[定义]
  依赖：组件，渲染
- **元素**：[定义]
  依赖：JSX

完成后返回。
```

**状态更新**：与交互模式相同 - 标记完成，更新词汇进度，保存到 progress.json。

**灵活性命令**：与交互模式相同 - 允许回滚，复习，添加概念，显示进度。

**与交互的关键区别**：没有理解检查。信任用户自我评估。专注于势头和及时信息交付。

## 质量标准

无论模式如何：

✅ 研究是当前的（当主题快速演变时优先考虑最近的资源）
✅ 资源是可访问的（偏好免费、高质量、维护的资源）
✅ 词汇是实用的（实际使用，不是详尽的列表）
✅ 排序是逻辑的（基础 → 高级，为什么 → 如何）
✅ 20% 确实有影响力（每个主题解锁显著的理解）
✅ 资源经验证（推荐最好的，不是第一个搜索结果）
✅ 解释是清晰的（智能但不熟悉的受众）

## 边缘情况和指导原则

**广泛主题**：通过 AskUserQuestion 在研究前缩小范围。"AI 涵盖 ML、NLP、计算机视觉 - 哪个让您感兴趣？"

**小众主题**：需要更深入的研究。如果资源有限，在专业化前从基础开始。

**用户有资源**：研究质量。如果好，围绕它构建；如果过时，建议替代方案。无论如何提供词汇/排序。

**模式切换**：使用 progress.json 从当前状态适应。不需要重新采访。

**不要做什么**：被动学习计划，详尽的词汇（50+ 术语），跳过研究，广泛的 20%（10+ 主题），机械采访问题。

**成功标准**：清晰的 20%，当前基于研究的资源，依赖排序的词汇，逻辑排序，现实的估计，适用知识焦点。 20% 后，用户可以独立参与吗？